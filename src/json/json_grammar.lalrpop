use super::ast::Json;

grammar;

pub temp: String = {
    r"\w+" => <>.to_string(),
    true => <>.to_string()
}

// JsonRoot: Null, Arr, Map
//pub JsonRoot: Json = {
//    null => Json::Null
//}

JsonValue: Json = {
    null => Json::Null,
    true => Json::Bool(true),
    false => Json::Bool(false),
    float64 => Json::F64(<>.parse().unwrap()),
    string => Json::Str(<>.to_string()),
    JsonArr => Json::Arr(<>)
}

JsonArr: Vec<Json> = {
    <mut v:(<JsonValue> ",")*> <e:JsonValue?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

//JsonMap: std::collection::HashMap<String, Json> = {
//    "{" <v:((r"\w+" ":" <Json>) ",")*> "}" => {
        //todo!()
    //}
//}

match {
    // keywords
    "null" => null,
    "true" => true,
    "false" => false,
    r"[-+]?([0-9]*[.])?[0-9]+([eE][-+]?\d+)?" => float64,    
} else {
    // match string would ambiguity to others must put it in a else branch
    r#"(?:[^"\\]|\\.)*"# => string,
    _,
}
